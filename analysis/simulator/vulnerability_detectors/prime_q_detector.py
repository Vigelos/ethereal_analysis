from .base_detector import BaseDetector
from util import *

PRIME_Q = "0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47"

class PrimeQFieldDetector(BaseDetector):
    
    def detect_after_execution(self, instruction: Instruction):
        if instruction.operation in ["GT", "LT"]:
            if self.executor.stack.has_element_on_topOrSecond(PRIME_Q):
                if self.debug:
                    print("Prime Q constraint detected at offset {}".format(instruction.offset))
                raise Exception("Prime Q constraint detected")
        
        if not self.executor.stack.has_element("[Variable] "+PRIME_Q):
            # break from this branch
            return False, "Prime Q not in stack any more"
            
        return True, "Normal"

    def get_entry_point_idx(self):
        # find the location of SNARK SCALAR FIELD in the instructions
        prime_q_idx = []
        for i, instruction in enumerate(self.instructions):
            if instruction.data == PRIME_Q:
                prime_q_idx.append(i)
        
        return prime_q_idx
        
        # # find the location of "LT", "GT" in the instructions
        # lt_gt_idx = []
        # for i, instruction in enumerate(self.instructions):
        #     if instruction.operation in ["LT", "GT"]:
        #         lt_gt_idx.append(i)

        # # for each SNARK SCALAR FIELD, find if there is "LT", "GT" after close distance
        # valid_prime_q_idx = []
        # for target_index in prime_q_idx:
        #     # if there are "LT", "GT" instructions in close distance
        #     can_execute = False
        #     for idx in lt_gt_idx:
        #         if idx > target_index and idx - target_index < 32:
        #             can_execute = True
        #             break
        #     if can_execute:
        #         valid_prime_q_idx.append(target_index)

        # return valid_prime_q_idx
    