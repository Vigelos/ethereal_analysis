from util import *


class BaseDetector:
    def __init__(self, instructions: list[Instruction], max_execution_length=64,debug=False):
        self.max_execution_length = max_execution_length
        self.instructions = instructions
        self.debug = debug
        self.executor = OperationExecutor(debug=self.debug)


    # define an abstract method to be implemented by the derived class
    def detect_after_execution(self,instruction: Instruction):
        raise NotImplementedError

    def get_entry_point_idx(self):
        raise NotImplementedError
    
    def extract_jumpdest(self, s):
        # extract the hex value from the string
        # for example, "[variable] 0x1234" -> 0x1234
        if s.split(" ")[0] != "[Variable]":
            return -1
        s = s.split(" ")[-1]
        # search for the offset in instructions
        for i in range(len(self.instructions)):
            if self.instructions[i].offset == s:
                return i
    
    def run(self, entry_point_idx):
        branches = {}
        branches[entry_point_idx] = (EVM_Stack(),0)

        while len(branches) > 0:
            # start execution from the entry point (like 0x0000)
            entry_point_idx = list(branches.keys())[0]
            self.executor.stack = branches[entry_point_idx][0].deep_copy()
            branch_step_count = branches[entry_point_idx][1]
            # remove the entry point from the branches
            branches.pop(entry_point_idx)

            for i in range(self.max_execution_length):
                
                # execute the instruction
                if self.executor.debug:
                    print("Executing instruction: ",end="")
                    self.instructions[entry_point_idx+i].print()
                status, jumpdest = self.executor.execute(self.instructions[entry_point_idx+i])
                continue_branch,reason = self.detect_after_execution(self.instructions[entry_point_idx+i])
                if continue_branch == False:
                    if self.executor.debug:
                        print("Branch terminated due to {}".format(reason))
                        print("remaining branches: ",branches.keys())
                    break

                if status == "Normal":
                    # continue to the next instruction
                    pass

                elif status == "JUMP":
                    jumpdest = self.extract_jumpdest(jumpdest)
                    if jumpdest == -1:
                        if self.executor.debug:
                            print("Unknown jump destination")
                        break
                    if self.executor.debug:
                        print("Jump to offset {}".format(jumpdest))

                    branches[jumpdest] = (self.executor.stack.deep_copy(),branch_step_count)

                    # jump to execute the instruction at the jumpdest
                    break

                elif status == "JUMPI":
                    jumpdest = self.extract_jumpdest(jumpdest)
                    if jumpdest == -1:
                        if self.executor.debug:
                            print("Unknown jump destination")
                        break
                    if self.executor.debug:
                        print("JumpI to offset {} to be executed".format(jumpdest))
                    branches[jumpdest] = (self.executor.stack.deep_copy(),branch_step_count)
                    # continue execution
                    pass

                elif status == "Halt":
                    if self.executor.debug:
                        print("Halt command received")
                        print("remaining branches: ",branches.keys())
                    break
                
                branch_step_count += 1
                if branch_step_count > self.max_execution_length:
                    if self.executor.debug:
                        print("Branch execution limit reached")
                        print("remaining branches: ",branches.keys())
                    break

        if self.executor.debug:
            print("Execution finished")        



            